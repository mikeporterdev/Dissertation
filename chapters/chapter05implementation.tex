%!TEX root = ../main.tex

% 1000-2000 Words

\chapter{Implementation}

\section{Application}
\subsubection{Android}
Android has been chosen for this application due to the large success and market hold of the operating system.

Primarily I will be targeting to support Android versions down to API level 16 (Jelly Bean 4.1).
This decision has been made as figure \ref{fig:AndroidVersions} shows that by supporting this far back, my application will be compatible with over 95\% of current phones. 
Older versions than this will not be targeted, as development and testing time is limited and many features will have to be limited due to lacking functionality within these older versions.

\subsubsection{Material Design}
In order to keep up with a modern and usable design for KidQuest, I have chosen to adhere to the most current standards set by Google for material design.

\subsubsection{Google Cloud Messaging}
The app will be responsible for relaying information between the parent and child clients in a reliable and timely manner.


\subsection{Facebook SDK}
In order to achieve better functionality in the social media features within the app, I will need to gather access to certain information about the user with their strict and explicit permission. 
Tying in the Facebook SDK into the app is the easiest way to gather this information in a secure manner that does not supercede the users wishes.
For example, using the Facebook SDK, I can prompt the user to allow the app permission to gather the users friends list, detect which of them also have used the app and have connected it to facebook and connect the two users as friends within my app.
%TODO: Reword this shit
This technology has strict ethical concerns however, as gathering this information on children has a potential risk for privacy and security concerns, therefore

\subsection{SQLite}

\subsubsection{Object-Relational Mapper}
I chose to use a pre-built Object Relational Mapping library to interface with the database, rather than crafting particular queries on an ad hoc basis.
This was primarily for more ease-of-use purposes than any performance reasons. 
I considered a variety of options for which library to use, initially deciding upon SugarORM due to its very quick learning curve and low use of boilerplate syntax. 

However, ultimately I decided to go with GreenDAO due to more community support - based on GreenDAO having four times the number of community questions on Stack Overflow - and better documentation.
GreenDAO allowed for me generate my MySQL tables, the Java objects and data access object (DAO) patterns by writing out the names of the tables, their properties and their relationships. 

\section{Server}
\subsection{Flask}
For the server-side implementation, I will need tools that allow me to easily create a Web-Service API and provide controlled access to these over the web.
For this task, I have chosen to use Flask as it is well established within the Python community and is incredibly low-effort to set up. 
Flask is suitable for both quick prototyping of web-services and reliable deployment/hosting of functionality over the internet.
By setting up 

\subsubsection{REST vs. SOAP}

\subsubsection{JSON vs. XML}
In order to communicate to the servers web services, I will need to decide upon a message format. 
REST is capable of using both XML and JSON to communicate over the web, 



As the project began it was clear that my initial database/class diagrams were drawn with incorrect assumptions about the project. 
Previously, I have mostly worked on systems that handle many users logging into a web application and designed databases as such. 
However, I did not account for the fact that with an android application, the database only needs to handle one user, which allowed me to use a simpler - less relationship heavy - database design.

\section{Server Rewrite}
When it came to be time to implement the parent app, it was realized that the initial designs for the server were not suitable for KidQuest.
I had initially tried to implement all workflows into the app and store the quests on the client end. 
The plan was then to send the quests to the parent phone using Google Cloud Messaging (GCM) and have them send back which quests were completed.
However, GCM was not suitable for moving the quests reliably and I found that it was too likely that information would be lost or become out of sync between parent and child devices.

Therefore, I decided to push most of the data and functionality to the server-side and have the app interact with the server to perform actions.
I still chose to use GCM for communicating from the server to a client in order to push notifications when tasks are confirmed or completed.

Making the move to server-side implementation did have two main consequences. 
Firstly, users would now require an internet connection to use the app so that it is able to communicate with the server.
This may cause an issue for users who have limited data plans on their phone contracts, however, as the app only communicates using JSON web service requests, data usage is kept to a minimum as requests are only a few kilobytes at a time.
Also, these users will often be conscious about their data usages anyway and will use android settings to restrict data, or only use the app on WiFi. 
Secondly, I would need to have increased security requirements surrounding the data, making sure that it is sufficiently encrypted during transfer to the server, and that the data stored on the server itself is protected as well.
All users were now required to create an account with the server in order to use the app, as the server needed to store the data on it's end rather than on the users' phone.

However, making the move to server-side functionality offers many benefits also.
By implementing everything server-side, the app has become significantly more portable. 
As all functionality rests in the server, any alternative apps - such as iOS or a web app - would be trivial to create as they only have to tie into the existing API, and the only code that would need to be created for these apps would be code to simply send and receive web service requests to the API.
Furthermore, it would also create the ability for the app to easily work between users using different versions. 
i.e. An parent using iOS would be able to monitor a child using an Android phone.

To handle logins securely, I implemented a token-based authentication system within the server. 
Upon their first request, the user submits their username and password within a HTTP POST request to the endpoint `api/token'.
The server then sends back an encrypted token that is derived out of various attributes of their account, which the user client stores.
The app will then authenticate itself with the server for every future request using this token.
This offers the main benefit that the app only has to store the token and not the username and password, which would leave it vulnerable to other (malicious) apps accessing it.
The app will also not have to send their username and password with each request that it makes to the API, minimizing the risk of the password within the request being intercepted in transport.
The password is only stored within the server, which has securely encrypted it with a salted hash.


Separating child and parent users was a mistake.

Interestingly, \cite{4597151} also states that testing a program tells us `little about its quality', arguing that the quality of a test case far outweighs sheer quantiy of tests.

\section{Test-Driven Development}
In the creation of a REST API, it is much easier to develop a test plan due to the clearly laid out workflow of the user. From the server's point of view, there are only a handful of requests that a user can make, and only a handful of tests for those requests. Before writing each endpoint of the server, I 

\section{Functional Testing}

\section{Unit Testing}

\section{Usability Testing}

\section{Beta Testing}